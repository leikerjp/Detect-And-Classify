# sqalchemy notes:
# camList = Camera.query.all()       : gets list of all sensors in database
# camFirst = Camera.query.first()    : gets first item from list
# camFilter = Camera.query.filter_by(id=<integer>).first() : get the camera with id equal to <integer>
# camera.images       : list of images with relationship to camera
# NOTE: primary_keys are autogenerated unless provided (which there needs to be a guarantee they are unique if provided)

from flask import request, make_response
from sqlalchemy import func
from server import app, db
from server.models import Camera, Image
import logging
import datetime
import cv2
import os
import numpy as np

@app.route("/display_image", methods=['POST'])
def display_image_data():
    if request.method == 'POST':
        # get file from message
        data = request.files['file']

        # 'read' the FileStorage object
        data_encoded = data.read()

        # Cast to a numpy buffer (i.e. convert from bytes to numpy array)
        image = np.frombuffer(data_encoded, dtype="uint8")

        # decode the image
        frame = cv2.imdecode(image, cv2.IMREAD_COLOR)

        # display
        cv2.imshow('frame', frame)
        cv2.waitKey(0)

        return r'', 200  # respond good - HTML unnecessary
    else:
        return '', 404  # no-one should've been able to get here! Return error

@app.route("/log_image", methods=['POST'])
def log_image():
    if request.method == 'POST':
        # get file from message
        # Note: message sent as:
        #    r = requests.post('http://localhost:5000/log_image', files=file, data=metadata)
        image_file = request.files['file']
        meta_data = request.form.to_dict()
        resp = make_response('', 200)

        ### Create the Camera and Image objects to save in database
        # Create sensor if it does not already exist
        camera = Camera.query.filter_by(id=meta_data['id']).first()
        if not camera:
            # New sensor, create entry for sensor and then save measurement
            camera = Camera(name=meta_data['name'])
            db.session.add(camera)
            db.session.commit()
            logging.info(f"New Camera : {camera.id}, {camera.name}")

            # Create new directory for the cameras images
            if not os.path.exists(os.path.join('images', f'{camera.name}')):
                os.mkdir(os.path.join('images', f'{camera.name}'))

            # create REST response (which will assign the camera it's unique ID)
            respDict = dict()
            respDict['id'] = camera.id
            resp = make_response(respDict, 200)

        # Save image and log image object
        # NOTE: can use camera_node=camera OR camera_id=int(meta_data['id'])
        image = Image(path="path", class_name="class_name", camera_node=camera)
        db.session.add(image)
        db.session.commit()

        ## the image ID is only generated after db.add and db.commit, so now we can create the path and
        # then update the image record in the database
        image.path = f"images/{camera.name}/{image.id}.jpg"
        db.session.commit()

        ## save image to disk (finally)
        image_file.save(image.path)

        # Record / SQL Table Maintenence
        num_images_to_keep_in_database = 25
        list_of_all_cameras = Camera.query.all()
        for camera in list_of_all_cameras:
            images = camera.images

            # There is probably a proper SQL way to do this, but I'm doing it this way because (A) it works for me
            # and (B) it seems to be the best way to get all the id's for me to also delete the files from disk.
            # 1. Get list of images ids.
            # 2. Sort the images ids in reverse, and only keep the specific amount we ant
            # 3. Remove the ids we want to keep from the original table, which leaves all id's we want to delete
            # 4. Iterate list of id's to be deleted (i) fetch the image (ii) delete from disk (iii) remove record
            image_ids = [image.id for image in images]
            image_ids_to_keep = sorted(image_ids, reverse=True)[:num_images_to_keep_in_database]
            image_ids_to_delete = [id for id in image_ids if id not in image_ids_to_keep]

            for image_id in image_ids_to_delete:
                # Get the image object by id
                image = db.session.query(Image).get(image_id)

                # Delete the image file from disc
                if os.path.exists(image.path):
                    os.remove(image.path)

                # Delete the record from the table
                db.session.delete(image)
                db.session.commit()

        return resp
    else:
        logging.warning("[WARNING] GET request to /log")
        return '', 404  # no-one should've been able to get here! Return error

@app.route("/classify_image", methods=['POST'])
def classify_image():
    return '', 404